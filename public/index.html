<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NextDev MP3 Player</title>
<style>
body { font-family: sans-serif; background: #111; color: #fff; padding: 20px; }
h1 { text-align: center; }
#controls, #equalizer { display:flex; justify-content:center; gap:10px; margin:10px 0; }
#playlist { list-style:none; padding:0; max-height:300px; overflow-y:auto; }
#playlist li { padding:10px; margin:5px 0; background:#333; cursor:pointer; border-radius:4px; transition: background 0.2s;}
#playlist li:hover { background:#444; }
#playlist li.playing { background:#2a5a83; font-weight:bold; }
input[type="range"] { width:100px; }
.slider-group { text-align:center; }
.track-info { text-align:center; margin:15px 0; font-style:italic; color:#aaa; }
.progress-container { width:100%; height:6px; background:#333; border-radius:3px; margin:15px 0; cursor:pointer; }
.progress-bar { height:100%; background:#4a8cff; border-radius:3px; width:0%; }
.time-display { display:flex; justify-content:space-between; margin-top:5px; font-size:12px; color:#aaa; }
.status { text-align:center; margin-top:10px; color:#4a8cff; font-size:14px; height:20px; }
</style>
</head>
<body>

<h1>üéß NextDev MP3 Player</h1>
<input type="file" id="fileInput" multiple accept=".mp3" />
<ul id="playlist"></ul>
<div class="track-info" id="trackInfo">No track selected</div>

<div class="progress-container" id="progressContainer">
  <div class="progress-bar" id="progressBar"></div>
</div>
<div class="time-display">
  <span id="currentTime">0:00</span>
  <span id="totalTime">0:00</span>
</div>

<div id="controls">
  <button id="prevBtn">‚èÆÔ∏è Prev</button>
  <button id="playBtn">‚ñ∂Ô∏è Play</button>
  <button id="pauseBtn">‚è∏Ô∏è Pause</button>
  <button id="stopBtn">‚èπÔ∏è Stop</button>
  <button id="nextBtn">‚è≠Ô∏è Next</button>
  <input type="range" id="volume" min="0" max="1" step="0.01" value="0.7" />
</div>

<div id="equalizer">
  <div class="slider-group"><label>Bass</label><br><input type="range" id="bass" min="-40" max="40" value="0" /></div>
  <div class="slider-group"><label>Mid</label><br><input type="range" id="mid" min="-40" max="40" value="0" /></div>
  <div class="slider-group"><label>Treble</label><br><input type="range" id="treble" min="-40" max="40" value="0" /></div>
</div>

<label>‚è±Ô∏è Crossfade Duration (sec):
  <input type="number" id="crossfadeDuration" value="5" min="0" max="30" />
</label>
<div class="status" id="status"></div>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
const fileInput = document.getElementById('fileInput');
const playlist = document.getElementById('playlist');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const volumeSlider = document.getElementById('volume');
const bassSlider = document.getElementById('bass');
const midSlider = document.getElementById('mid');
const trebleSlider = document.getElementById('treble');
const crossfadeInput = document.getElementById('crossfadeDuration');
const trackInfo = document.getElementById('trackInfo');
const progressBar = document.getElementById('progressBar');
const progressContainer = document.getElementById('progressContainer');
const currentTimeDisplay = document.getElementById('currentTime');
const totalTimeDisplay = document.getElementById('totalTime');
const status = document.getElementById('status');

let audioCtx, gainNode, bass, mid, treble;
let audioBuffers = [], currentIndex = -1, isPlaying = false;
let currentSource = null, nextSource = null;
let startTime = 0, pausedAt = 0, animationFrame = null;
let isCrossfading = false;

fileInput.addEventListener('change', (e) => {
  for (const file of Array.from(e.target.files)) {
    const li = document.createElement('li');
    li.textContent = file.name;
    li.file = file;
    playlist.appendChild(li);
  }
});

new Sortable(playlist, { animation:150 });

playlist.addEventListener('click', async (e) => {
  if (e.target.tagName==='LI') {
    currentIndex=[...playlist.children].indexOf(e.target);
    await playTrack(currentIndex);
  }
});

progressContainer.addEventListener('click', (e)=>{
  if(!currentSource || !currentSource.buffer) return;
  const rect = progressContainer.getBoundingClientRect();
  const pos = (e.clientX-rect.left)/rect.width;
  pausedAt = pos * currentSource.buffer.duration;
  startTime = audioCtx.currentTime - pausedAt;
  stopSource(currentSource);
  currentSource=null;
  playTrack(currentIndex, true);
});

function setupAudioCtx(){
  if(audioCtx && audioCtx.state!=='closed') return;
  audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  gainNode=audioCtx.createGain();
  gainNode.gain.value=volumeSlider.value;
  bass=audioCtx.createBiquadFilter(); bass.type='lowshelf'; bass.frequency.value=200;
  mid=audioCtx.createBiquadFilter(); mid.type='peaking'; mid.frequency.value=1000;
  treble=audioCtx.createBiquadFilter(); treble.type='highshelf'; treble.frequency.value=3000;
  bass.connect(mid); mid.connect(treble); treble.connect(gainNode); gainNode.connect(audioCtx.destination);
}

async function playTrack(index, resume=false){
  if(playlist.children.length===0) return;
  stopAllSources();

  setupAudioCtx();
  currentIndex=index;

  // Load buffer
  const li=playlist.children[index];
  if(!audioBuffers[index]){
    const arrayBuffer=await li.file.arrayBuffer();
    audioBuffers[index]=await audioCtx.decodeAudioData(arrayBuffer);
  }

  currentSource=audioCtx.createBufferSource();
  currentSource.buffer=audioBuffers[index];
  currentSource.connect(bass);

  startTime=audioCtx.currentTime - (resume ? pausedAt:0);
  currentSource.start(0,resume?pausedAt:0);
  isPlaying=true;
  pausedAt=0;

  updateUI();

  currentSource.onended=()=>{ if(!isCrossfading) nextTrackWithCrossfade(); };

  requestAnimationFrame(updateProgress);
}

function stopSource(source){
  if(!source) return;
  try{source.stop(); source.disconnect();}catch(e){}
}

function stopAllSources(){
  stopSource(currentSource); stopSource(nextSource);
  currentSource=null; nextSource=null;
  isPlaying=false; isCrossfading=false;
  pausedAt=0;
  progressBar.style.width='0%';
  currentTimeDisplay.textContent='0:00';
  totalTimeDisplay.textContent='0:00';
  status.textContent='';
}

function nextTrackWithCrossfade(){
  if(playlist.children.length<=1) return;
  const nextIndex=(currentIndex+1)%playlist.children.length;
  isCrossfading=true;
  status.textContent='Crossfading...';

  (async ()=>{
    const li=playlist.children[nextIndex];
    if(!audioBuffers[nextIndex]){
      const arrayBuffer=await li.file.arrayBuffer();
      audioBuffers[nextIndex]=await audioCtx.decodeAudioData(arrayBuffer);
    }

    nextSource=audioCtx.createBufferSource();
    nextSource.buffer=audioBuffers[nextIndex];

    const oldGain=audioCtx.createGain();
    const newGain=audioCtx.createGain();

    currentSource.disconnect(); currentSource.connect(oldGain); oldGain.connect(bass);
    nextSource.connect(newGain); newGain.connect(bass);

    const duration=parseFloat(crossfadeInput.value)||0;
    const now=audioCtx.currentTime;
    oldGain.gain.setValueAtTime(1,now);
    oldGain.gain.linearRampToValueAtTime(0,now+duration);
    newGain.gain.setValueAtTime(0,now);
    newGain.gain.linearRampToValueAtTime(1,now+duration);

    startTime=audioCtx.currentTime;
    pausedAt=0;
    currentIndex=nextIndex;
    updateUI();
    nextSource.onended=()=>{ if(!isCrossfading) nextTrackWithCrossfade(); };
    nextSource.start();

    setTimeout(()=>{
      stopSource(currentSource);
      currentSource=nextSource;
      nextSource=null;
      isCrossfading=false;
      status.textContent='';
    }, duration*1000);
  })();
}

function updateProgress(){
  if(!currentSource || !currentSource.buffer) return;
  const currentTime=pausedAt + (audioCtx.currentTime - startTime);
  const duration=currentSource.buffer.duration;
  const percent=(currentTime/duration)*100;
  progressBar.style.width=percent+'%';
  currentTimeDisplay.textContent=formatTime(currentTime);
  totalTimeDisplay.textContent=formatTime(duration);

  if(isPlaying && !isCrossfading && duration-currentTime<=parseFloat(crossfadeInput.value||0) && playlist.children.length>1){
    nextTrackWithCrossfade();
  }

  if(isPlaying) requestAnimationFrame(updateProgress);
}

function updateUI(){
  const li=playlist.children[currentIndex];
  [...playlist.children].forEach(i=>i.classList.remove('playing'));
  li.classList.add('playing');
  trackInfo.textContent='Now Playing: '+li.file.name;
}

function formatTime(sec){ const m=Math.floor(sec/60); const s=Math.floor(sec%60); return `${m}:${s<10?'0':''}${s}`; }

playBtn.addEventListener('click',async()=>{
  if(audioCtx && audioCtx.state==='suspended') await audioCtx.resume();
  if(!isPlaying && currentIndex>=0) await playTrack(currentIndex);
  else if(!isPlaying && currentIndex===-1 && playlist.children.length>0) await playTrack(0);
});

pauseBtn.addEventListener('click',()=>{
  if(currentSource){
    pausedAt+=audioCtx.currentTime - startTime;
    stopSource(currentSource);
    currentSource=null;
    isPlaying=false;
  }
});

stopBtn.addEventListener('click',()=>{ stopAllSources(); trackInfo.textContent='Playback stopped'; });

prevBtn.addEventListener('click',()=>{ const prev=(currentIndex-1+playlist.children.length)%playlist.children.length; playTrack(prev); });
nextBtn.addEventListener('click',()=>{ const next=(currentIndex+1)%playlist.children.length; playTrack(next); });

volumeSlider.addEventListener('input',()=>{ if(gainNode) gainNode.gain.setValueAtTime(volumeSlider.value,audioCtx.currentTime); });
bassSlider.addEventListener('input',()=>{ if(bass) bass.gain.value=bassSlider.value; });
midSlider.addEventListener('input',()=>{ if(mid) mid.gain.value=midSlider.value; });
trebleSlider.addEventListener('input',()=>{ if(treble) treble.gain.value=trebleSlider.value; });
</script>
</body>
</html>
