<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NextDev MP3 Player</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #fff;
      padding: 20px;
    }
    h1 { text-align: center; }
    #controls, #equalizer {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
    }
    #playlist {
      list-style: none;
      padding: 0;
    }
    #playlist li {
      padding: 5px;
      margin: 5px 0;
      background: #333;
      cursor: grab;
    }
    input[type="range"] {
      width: 100px;
    }
    .slider-group {
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>üéß NextDev MP3 Player</h1>

  <input type="file" id="fileInput" multiple accept=".mp3" />
  <ul id="playlist"></ul>

  <div id="controls">
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="stopBtn">‚èπÔ∏è Stop</button>
    <input type="range" id="volume" min="0" max="1" step="0.01" />
  </div>

  <div id="equalizer">
    <div class="slider-group">
      <label>Bass</label><br>
      <input type="range" id="bass" min="-40" max="40" value="0" />
    </div>
    <div class="slider-group">
      <label>Mid</label><br>
      <input type="range" id="mid" min="-40" max="40" value="0" />
    </div>
    <div class="slider-group">
      <label>Treble</label><br>
      <input type="range" id="treble" min="-40" max="40" value="0" />
    </div>
  </div>

  <label>‚è±Ô∏è Crossfade Duration (sec): 
    <input type="number" id="crossfadeDuration" value="5" min="0" max="30" />
  </label>

  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script>
    const fileInput = document.getElementById('fileInput');
    const playlist = document.getElementById('playlist');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const volumeSlider = document.getElementById('volume');
    const bassSlider = document.getElementById('bass');
    const midSlider = document.getElementById('mid');
    const trebleSlider = document.getElementById('treble');
    const crossfadeInput = document.getElementById('crossfadeDuration');

    let audioCtx, source, gainNode;
    let bass, mid, treble;
    let audioBuffers = [];
    let currentIndex = -1;
    let isPlaying = false;

    fileInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files);
      for (const file of files) {
        const li = document.createElement('li');
        li.textContent = file.name;
        li.dataset.filename = file.name;
        li.file = file;
        playlist.appendChild(li);
      }
    });

    new Sortable(playlist, {
      animation: 150,
    });

    playlist.addEventListener('click', async (e) => {
      if (e.target.tagName === 'LI') {
        currentIndex = Array.from(playlist.children).indexOf(e.target);
        await playSelectedTrack();
      }
    });

    function setupAudioNodes() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();

      bass = audioCtx.createBiquadFilter();
      bass.type = 'lowshelf';
      bass.frequency.value = 200;

      mid = audioCtx.createBiquadFilter();
      mid.type = 'peaking';
      mid.frequency.value = 1000;

      treble = audioCtx.createBiquadFilter();
      treble.type = 'highshelf';
      treble.frequency.value = 3000;

      bass.connect(mid);
      mid.connect(treble);
      treble.connect(gainNode);
      gainNode.connect(audioCtx.destination);
    }

    async function playSelectedTrack() {
      stopAudio();

      if (!audioCtx) setupAudioNodes();

      const li = playlist.children[currentIndex];
      const file = li.file;

      const arrayBuffer = await file.arrayBuffer();
      const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

      const newSource = audioCtx.createBufferSource();
      newSource.buffer = audioBuffer;

      // Connect EQ
      newSource.connect(bass);

      const crossfade = parseFloat(crossfadeInput.value || '0');
      if (source) {
        crossfadeTracks(source, newSource, crossfade);
      } else {
        gainNode.gain.setValueAtTime(volumeSlider.value, audioCtx.currentTime);
        newSource.start();
      }

      source = newSource;
      source.start();
      isPlaying = true;
    }

    function stopAudio() {
      if (source) {
        source.stop();
        source.disconnect();
        source = null;
      }
    }

    playBtn.addEventListener('click', async () => {
      if (!isPlaying && currentIndex >= 0) {
        await playSelectedTrack();
      } else if (!isPlaying && currentIndex === -1 && playlist.children.length > 0) {
        currentIndex = 0;
        await playSelectedTrack();
      }
    });

    pauseBtn.addEventListener('click', () => {
      if (audioCtx) {
        audioCtx.suspend();
        isPlaying = false;
      }
    });

    stopBtn.addEventListener('click', () => {
      stopAudio();
      isPlaying = false;
    });

    volumeSlider.addEventListener('input', () => {
      if (gainNode) gainNode.gain.value = volumeSlider.value;
    });

    bassSlider.addEventListener('input', () => bass.gain.value = bassSlider.value);
    midSlider.addEventListener('input', () => mid.gain.value = midSlider.value);
    trebleSlider.addEventListener('input', () => treble.gain.value = trebleSlider.value);

    function crossfadeTracks(oldSource, newSource, duration) {
      const oldGain = audioCtx.createGain();
      const newGain = audioCtx.createGain();

      oldSource.disconnect();
      newSource.disconnect();

      oldSource.connect(oldGain);
      newSource.connect(newGain);

      oldGain.connect(audioCtx.destination);
      newGain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      oldGain.gain.setValueAtTime(1, now);
      oldGain.gain.linearRampToValueAtTime(0, now + duration);

      newGain.gain.setValueAtTime(0, now);
      newGain.gain.linearRampToValueAtTime(volumeSlider.value, now + duration);

      newSource.start();
      source = newSource;
    }
  </script>
</body>
</html>
