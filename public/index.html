<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>üéß NextDev MP3 Player</title>
<style>
  body { background: #111; color: #fff; font-family: sans-serif; padding: 20px; }
  h1 { text-align: center; }
  #player { max-width: 600px; margin: auto; }
  #controls, #equalizer { display: flex; justify-content: center; gap: 10px; margin: 10px 0; }
  button { padding: 8px 12px; border-radius: 5px; border: none; cursor: pointer; background: #222; color: #fff; transition: background 0.2s; }
  button:hover { background: #444; }
  #playlist { list-style: none; padding: 0; max-height: 250px; overflow-y: auto; }
  #playlist li { padding: 10px; margin: 5px 0; background: #333; cursor: grab; border-radius: 4px; }
  #playlist li.playing { background: #2a5a83; font-weight: bold; }
  input[type="range"] { width: 100px; }
  .track-info { text-align: center; margin: 10px 0; color: #aaa; font-style: italic; }
  .progress-container { width: 100%; height: 6px; background: #333; border-radius: 3px; margin: 10px 0; cursor: pointer; }
  .progress-bar { height: 100%; background: #4a8cff; width: 0%; border-radius: 3px; }
  .time-display { display: flex; justify-content: space-between; font-size: 12px; color: #aaa; }
  .status { text-align:center; color:#4a8cff; font-size:14px; margin-top:5px; height:20px; }
  /* cassette animation */
  #cassette { width: 200px; height: 120px; margin: auto; background: #222; border-radius: 10px; position: relative; overflow: hidden; }
  .reel { width: 40px; height: 40px; border-radius: 50%; border: 4px solid #888; position: absolute; top: 40px; }
  .left { left: 30px; }
  .right { right: 30px; }
  .spinning { animation: spin 2s linear infinite; }
  @keyframes spin { 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);} }
</style>
</head>
<body>
<h1>üéß NextDev MP3 Player</h1>
<div id="player">
  <input type="file" id="fileInput" multiple accept=".mp3">
  <ul id="playlist"></ul>
  <div id="cassette">
    <div class="reel left" id="leftReel"></div>
    <div class="reel right" id="rightReel"></div>
  </div>
  <div class="track-info" id="trackInfo">No track selected</div>

  <div class="progress-container" id="progressContainer">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <div class="time-display">
    <span id="currentTime">0:00</span>
    <span id="totalTime">0:00</span>
  </div>

  <div id="controls">
    <button id="prevBtn">‚èÆÔ∏è Prev</button>
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="stopBtn">‚èπÔ∏è Stop</button>
    <button id="nextBtn">‚è≠Ô∏è Next</button>
    <button id="shuffleBtn">üîÄ Shuffle</button>
    <button id="repeatBtn">üîÅ Repeat</button>
    <input type="range" id="volume" min="0" max="1" step="0.01" value="0.7">
  </div>

  <div id="equalizer">
    <div><label>Bass</label><br><input type="range" id="bass" min="-40" max="40" value="0"></div>
    <div><label>Mid</label><br><input type="range" id="mid" min="-40" max="40" value="0"></div>
    <div><label>Treble</label><br><input type="range" id="treble" min="-40" max="40" value="0"></div>
  </div>

  <label>‚è±Ô∏è Crossfade Duration (sec): <input type="number" id="crossfadeDuration" value="5" min="0" max="30"></label>
  <div class="status" id="status"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
const fileInput = document.getElementById('fileInput');
const playlist = document.getElementById('playlist');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const repeatBtn = document.getElementById('repeatBtn');
const volumeSlider = document.getElementById('volume');
const bassSlider = document.getElementById('bass');
const midSlider = document.getElementById('mid');
const trebleSlider = document.getElementById('treble');
const crossfadeInput = document.getElementById('crossfadeDuration');
const trackInfo = document.getElementById('trackInfo');
const progressBar = document.getElementById('progressBar');
const progressContainer = document.getElementById('progressContainer');
const currentTimeDisplay = document.getElementById('currentTime');
const totalTimeDisplay = document.getElementById('totalTime');
const status = document.getElementById('status');
const leftReel = document.getElementById('leftReel');
const rightReel = document.getElementById('rightReel');

let audioCtx, currentSource, gainNode, bass, mid, treble;
let audioBuffers = [];
let currentIndex = -1, isPlaying=false;
let startTime=0, pausedAt=0, animationFrame;
let shuffle=false, repeat=false;

// --- Playlist setup ---
fileInput.addEventListener('change', e=>{
  for(const file of Array.from(e.target.files)){
    const li=document.createElement('li');
    li.textContent=file.name;
    li.file=file;
    playlist.appendChild(li);
  }
});
new Sortable(playlist,{animation:150});
playlist.addEventListener('click', async e=>{
  if(e.target.tagName==='LI'){
    currentIndex=[...playlist.children].indexOf(e.target);
    await playTrack(currentIndex);
  }
});

// --- Audio setup ---
function setupAudio() {
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  gainNode = audioCtx.createGain();
  bass=audioCtx.createBiquadFilter(); bass.type='lowshelf'; bass.frequency.value=200;
  mid=audioCtx.createBiquadFilter(); mid.type='peaking'; mid.frequency.value=1000;
  treble=audioCtx.createBiquadFilter(); treble.type='highshelf'; treble.frequency.value=3000;
  bass.connect(mid); mid.connect(treble); treble.connect(gainNode); gainNode.connect(audioCtx.destination);
  gainNode.gain.value=volumeSlider.value;
}

async function loadBuffer(index){
  if(audioBuffers[index]) return audioBuffers[index];
  const file=playlist.children[index].file;
  const arrayBuffer=await file.arrayBuffer();
  const buffer=await audioCtx.decodeAudioData(arrayBuffer);
  audioBuffers[index]=buffer;
  return buffer;
}

// --- Play Track ---
async function playTrack(index){
  stopCurrent();
  if(!audioCtx) setupAudio();
  const buffer=await loadBuffer(index);
  currentSource=audioCtx.createBufferSource();
  currentSource.buffer=buffer;
  currentSource.connect(bass);
  currentSource.start(0,0);
  startTime=audioCtx.currentTime;
  isPlaying=true;
  updateUI();
  currentSource.onended=()=>{ if(isPlaying) nextTrack(true); };
  spinReels(true);
}

function stopCurrent(){
  if(currentSource){ currentSource.stop(); currentSource.disconnect(); currentSource=null; }
  isPlaying=false;
  spinReels(false);
}

function updateUI(){
  const li=playlist.children[currentIndex];
  [...playlist.children].forEach(li=>li.classList.remove('playing'));
  if(li) li.classList.add('playing');
  trackInfo.textContent=li?li.file.name:'No track';
  if(animationFrame) cancelAnimationFrame(animationFrame);
  updateProgress();
}

function updateProgress(){
  if(!currentSource||!currentSource.buffer) return;
  const elapsed=audioCtx.currentTime-startTime;
  const duration=currentSource.buffer.duration;
  progressBar.style.width=Math.min((elapsed/duration)*100,100)+'%';
  currentTimeDisplay.textContent=formatTime(elapsed);
  totalTimeDisplay.textContent=formatTime(duration);
  const crossfade=parseFloat(crossfadeInput.value||'0');
  if(crossfade>0 && duration-elapsed<=crossfade && isPlaying) nextTrack(true);
  if(isPlaying) animationFrame=requestAnimationFrame(updateProgress);
}

function formatTime(sec){ const m=Math.floor(sec/60); const s=Math.floor(sec%60); return `${m}:${s<10?'0':''}${s}`; }

function crossfadeTracks(oldSrc,newSrc,duration){
  const oldGain=audioCtx.createGain(), newGain=audioCtx.createGain();
  oldSrc.disconnect(); oldSrc.connect(oldGain); oldGain.connect(bass);
  newSrc.connect(newGain); newGain.connect(bass);
  const now=audioCtx.currentTime;
  oldGain.gain.setValueAtTime(1,now); oldGain.gain.linearRampToValueAtTime(0,now+duration);
  newGain.gain.setValueAtTime(0,now); newGain.gain.linearRampToValueAtTime(1,now+duration);
  newSrc.start();
  oldSrc.stop(now+duration);
  currentSource=newSrc;
}

// --- Next/Prev ---
async function nextTrack(auto=false){
  if(playlist.children.length===0) return;
  let nextIndex;
  if(shuffle) nextIndex=Math.floor(Math.random()*playlist.children.length);
  else { nextIndex=currentIndex+1; if(nextIndex>=playlist.children.length){ if(repeat) nextIndex=0; else { stopCurrent(); return; } } }
  const crossfade=parseFloat(crossfadeInput.value||'0');
  if(auto && crossfade>0 && currentSource){
    const old=currentSource;
    currentIndex=nextIndex;
    const buffer=await loadBuffer(nextIndex);
    const newSrc=audioCtx.createBufferSource(); newSrc.buffer=buffer;
    crossfadeTracks(old,newSrc,crossfade);
    updateUI();
    newSrc.onended=()=>{ if(isPlaying) nextTrack(true); };
  } else { currentIndex=nextIndex; await playTrack(nextIndex); }
}

async function prevTrack(){ if(playlist.children.length===0) return; currentIndex=currentIndex-1<0?playlist.children.length-1:currentIndex-1; await playTrack(currentIndex); }

// --- Controls ---
playBtn.addEventListener('click', async()=>{ if(audioCtx&&audioCtx.state==='suspended') await audioCtx.resume(); if(!isPlaying) { if(currentIndex<0) currentIndex=0; await playTrack(currentIndex); } });
pauseBtn.addEventListener('click', ()=>{ if(isPlaying){ pausedAt=audioCtx.currentTime-startTime; currentSource.stop(); isPlaying=false; spinReels(false); }});
stopBtn.addEventListener('click', stopCurrent);
nextBtn.addEventListener('click', ()=>nextTrack(false));
prevBtn.addEventListener('click', prevTrack);
shuffleBtn.addEventListener('click', ()=>{ shuffle=!shuffle; shuffleBtn.style.background=shuffle?'#4a8cff':'#222'; });
repeatBtn.addEventListener('click', ()=>{ repeat=!repeat; repeatBtn.style.background=repeat?'#4a8cff':'#222'; });
volumeSlider.addEventListener('input', ()=>{ if(gainNode) gainNode.gain.setValueAtTime(volumeSlider.value,audioCtx.currentTime); });
bassSlider.addEventListener('input', ()=>{ if(bass) bass.gain.value=bassSlider.value; });
midSlider.addEventListener('input', ()=>{ if(mid) mid.gain.value=midSlider.value; });
trebleSlider.addEventListener('input', ()=>{ if(treble) treble.gain.value=trebleSlider.value; });

// --- Reel animation ---
function spinReels(on){ if(on){ leftReel.classList.add('spinning'); rightReel.classList.add('spinning'); } else { leftReel.classList.remove('spinning'); rightReel.classList.remove('spinning'); } }

// --- Progress click seek ---
progressContainer.addEventListener('click', e=>{
  if(!currentSource||!currentSource.buffer) return;
  const rect=progressContainer.getBoundingClientRect();
  const clickPos=(e.clientX-rect.left)/rect.width;
  const seekTime=clickPos*currentSource.buffer.duration;
  currentSource.stop();
  currentSource.disconnect();
  currentSource=null;
  pausedAt=seekTime;
  playTrack(currentIndex);
});
</script>
</body>
</html>
