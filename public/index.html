<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NextDev MP3 Player</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #fff;
      padding: 20px;
    }
    h1 { text-align: center; }
    #controls, #equalizer {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
    }
    #playlist {
      list-style: none;
      padding: 0;
      max-height: 300px;
      overflow-y: auto;
    }
    #playlist li {
      padding: 10px;
      margin: 5px 0;
      background: #333;
      cursor: grab;
      border-radius: 4px;
      transition: background 0.2s;
    }
    #playlist li:hover { background: #444; }
    #playlist li.playing {
      background: #2a5a83;
      font-weight: bold;
    }
    input[type="range"] { width: 100px; }
    .slider-group { text-align: center; }
    .track-info {
      text-align: center;
      margin: 15px 0;
      font-style: italic;
      color: #aaa;
    }
    .progress-container {
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      margin: 15px 0;
      cursor: pointer;
    }
    .progress-bar {
      height: 100%;
      background: #4a8cff;
      border-radius: 3px;
      width: 0%;
    }
    .time-display {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      font-size: 12px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <h1>üéß NextDev MP3 Player</h1>

  <input type="file" id="fileInput" multiple accept=".mp3" />
  <ul id="playlist"></ul>
  <div class="track-info" id="trackInfo">No track selected</div>

  <div class="progress-container" id="progressContainer">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <div class="time-display">
    <span id="currentTime">0:00</span>
    <span id="totalTime">0:00</span>
  </div>

  <div id="controls">
    <button id="prevBtn">‚èÆÔ∏è Prev</button>
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="stopBtn">‚èπÔ∏è Stop</button>
    <button id="nextBtn">‚è≠Ô∏è Next</button>
    <input type="range" id="volume" min="0" max="1" step="0.01" value="0.7" />
  </div>

  <div id="equalizer">
    <div class="slider-group"><label>Bass</label><br><input type="range" id="bass" min="-40" max="40" value="0" /></div>
    <div class="slider-group"><label>Mid</label><br><input type="range" id="mid" min="-40" max="40" value="0" /></div>
    <div class="slider-group"><label>Treble</label><br><input type="range" id="treble" min="-40" max="40" value="0" /></div>
  </div>

  <label>‚è±Ô∏è Crossfade Duration (sec):
    <input type="number" id="crossfadeDuration" value="5" min="0" max="30" />
  </label>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
  const fileInput  = document.getElementById('fileInput');
  const playlist   = document.getElementById('playlist');
  const playBtn    = document.getElementById('playBtn');
  const pauseBtn   = document.getElementById('pauseBtn');
  const stopBtn    = document.getElementById('stopBtn');
  const prevBtn    = document.getElementById('prevBtn');
  const nextBtn    = document.getElementById('nextBtn');
  const volumeSlider=document.getElementById('volume');
  const bassSlider = document.getElementById('bass');
  const midSlider  = document.getElementById('mid');
  const trebleSlider=document.getElementById('treble');
  const crossfadeInput=document.getElementById('crossfadeDuration');
  const trackInfo  = document.getElementById('trackInfo');
  const progressBar= document.getElementById('progressBar');
  const progressContainer= document.getElementById('progressContainer');
  const currentTimeDisplay=document.getElementById('currentTime');
  const totalTimeDisplay=document.getElementById('totalTime');

  let audioCtx, source, gainNode;
  let bass, mid, treble;
  let audioBuffers=[];
  let currentIndex=-1, isPlaying=false;
  let startTime=0, pausedAt=0, animationFrame;

  fileInput.addEventListener('change',(e)=>{
    for(const file of Array.from(e.target.files)){
      const li=document.createElement('li');
      li.textContent=file.name; li.file=file;
      playlist.appendChild(li);
    }
  });

  new Sortable(playlist,{animation:150});

  playlist.addEventListener('click',async(e)=>{
    if(e.target.tagName==='LI'){
      currentIndex=[...playlist.children].indexOf(e.target);
      await playSelectedTrack();
    }
  });

  progressContainer.addEventListener('click',(e)=>{
    if(!source||!source.buffer)return;
    const rect=progressContainer.getBoundingClientRect();
    const pos=(e.clientX-rect.left)/rect.width;
    const seek=pos*source.buffer.duration;
    source.stop();source.disconnect();
    pausedAt=seek; createAndStartSource();
  });

  function setupAudioNodes(){
    if(audioCtx&&audioCtx.state!=='closed')return;
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    gainNode=audioCtx.createGain();

    bass=audioCtx.createBiquadFilter();bass.type='lowshelf';bass.frequency.value=200;
    mid =audioCtx.createBiquadFilter();mid.type='peaking';mid.frequency.value=1000;
    treble=audioCtx.createBiquadFilter();treble.type='highshelf';treble.frequency.value=3000;

    bass.connect(mid);mid.connect(treble);treble.connect(gainNode);gainNode.connect(audioCtx.destination);
    gainNode.gain.value=volumeSlider.value;
  }

  function createAndStartSource(){
    if(!audioCtx)setupAudioNodes();
    const li=playlist.children[currentIndex];
    if(source){source.stop();source.disconnect();}
    source=audioCtx.createBufferSource();
    source.buffer=audioBuffers[currentIndex];
    source.connect(bass);
    startTime=audioCtx.currentTime-pausedAt;
    source.start(0,pausedAt);

    // mark current
    trackInfo.textContent=`Now Playing: ${li.file.name}`;
    [...playlist.children].forEach(li=>li.classList.remove('playing'));
    li.classList.add('playing');

    if(animationFrame)cancelAnimationFrame(animationFrame);
    updateProgress();

    source.onended=(()=>{ if(isPlaying)playNextTrack(); });
  }

  async function playSelectedTrack(){
    stopAudio(); isPlaying=true;
    if(!audioCtx)setupAudioNodes();
    const li=playlist.children[currentIndex];
    if(!audioBuffers[currentIndex]){
      const arr=await li.file.arrayBuffer();
      audioBuffers[currentIndex]=await audioCtx.decodeAudioData(arr);
    }
    pausedAt=0; createAndStartSource();
  }

  function stopAudio(){
    if(source){source.stop();source.disconnect();source=null;}
    pausedAt=0;isPlaying=false;
    if(animationFrame)cancelAnimationFrame(animationFrame);
    progressBar.style.width='0%';
    currentTimeDisplay.textContent='0:00';
  }

  function crossfadeTracks(oldSource,newSource,d){
    if(d<=0){oldSource.stop();oldSource.disconnect();newSource.connect(bass);newSource.start();source=newSource;return;}
    const og=audioCtx.createGain(), ng=audioCtx.createGain();
    oldSource.disconnect();oldSource.connect(og);og.connect(bass);
    newSource.connect(ng);ng.connect(bass);
    const t=audioCtx.currentTime;
    og.gain.setValueAtTime(1,t); og.gain.linearRampToValueAtTime(0,t+d);
    ng.gain.setValueAtTime(0,t); ng.gain.linearRampToValueAtTime(1,t+d);
    newSource.start();oldSource.stop(t+d);
    source=newSource;
  }

  function updateProgress(){
    if(!source||!source.buffer)return;
    const ct=pausedAt+(audioCtx.currentTime-startTime);
    const dur=source.buffer.duration;
    progressBar.style.width=`${(ct/dur)*100}%}`;
    currentTimeDisplay.textContent=format(ct);
    totalTimeDisplay.textContent=format(dur);

    // ----- AUTO FADE -----
    const cf=parseFloat(crossfadeInput.value);
    if(dur-ct<=cf && !source.crossfading){
      source.crossfading=true;
      let next=currentIndex+1; if(next>=playlist.children.length)next=0;
      const fileNext=playlist.children[next].file;
      (async()=>{
        if(!audioBuffers[next]){
          const ab=await fileNext.arrayBuffer();
          audioBuffers[next]=await audioCtx.decodeAudioData(ab);
        }
        const newS=audioCtx.createBufferSource();
        newS.buffer=audioBuffers[next];
        crossfadeTracks(source,newS,cf);
        currentIndex=next;
        newS.onended=()=>{ if(isPlaying)playNextTrack(); };
      })();
    }
    if(isPlaying)animationFrame=requestAnimationFrame(updateProgress);
  }

  function format(s){
    const m=Math.floor(s/60),sec=Math.floor(s%60);
    return`${m}:${sec<10?'0':''}${sec}`;
  }

  playBtn.addEventListener('click',async()=>{
    if(audioCtx&&audioCtx.state==='suspended')await audioCtx.resume();
    if(!isPlaying&&currentIndex>=0)await playSelectedTrack();
    else if(!isPlaying&&currentIndex===-1&&playlist.children.length){currentIndex=0;await playSelectedTrack();}
  });

  pauseBtn.addEventListener('click',()=>{
    if(audioCtx&&source){
      pausedAt+=audioCtx.currentTime-startTime;
      source.stop();source.disconnect();source=null;
      isPlaying=false;if(animationFrame)cancelAnimationFrame(animationFrame);
    }
  });

  stopBtn.addEventListener('click',()=>{
    stopAudio();
    trackInfo.textContent='Playback stopped';
    [...playlist.children].forEach(li=>li.classList.remove('playing'));
  });

  prevBtn.addEventListener('click',()=>{ if(!playlist.children.length)return;
    currentIndex--; if(currentIndex<0)currentIndex=playlist.children.length-1; playSelectedTrack();
  });

  nextBtn.addEventListener('click',()=>{ playNextTrack(); });

  function playNextTrack(){
    if(!playlist.children.length)return;
    currentIndex++; if(currentIndex>=playlist.children.length)currentIndex=0; playSelectedTrack();
  }

  volumeSlider.addEventListener('input',()=>{ if(gainNode)gainNode.gain.setValueAtTime(volumeSlider.value,audioCtx.currentTime); });
  bassSlider.addEventListener('input',()=>{ if(bass)bass.gain.value=bassSlider.value; });
  midSlider.addEventListener('input',()=>{ if(mid)mid.gain.value=midSlider.value; });
  trebleSlider.addEventListener('input',()=>{ if(treble)treble.gain.value=trebleSlider.value; });
</script>
</body>
</html>
