<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>üéß NextDev MP3 Player</title>
<style>
  body { background: #111; color: #fff; font-family: sans-serif; padding: 20px; }
  h1 { text-align: center; }
  #player { max-width: 600px; margin: auto; }
  #controls, #equalizer { display: flex; justify-content: center; gap: 10px; margin: 10px 0; }
  button { padding: 8px 12px; border-radius: 5px; border: none; cursor: pointer; background: #222; color: #fff; transition: background 0.2s; }
  button:hover { background: #444; }
  #playlist { list-style: none; padding: 0; max-height: 250px; overflow-y: auto; }
  #playlist li { padding: 10px; margin: 5px 0; background: #333; cursor: grab; border-radius: 4px; }
  #playlist li.playing { background: #2a5a83; font-weight: bold; }
  input[type="range"] { width: 100px; }
  .track-info { text-align: center; margin: 10px 0; color: #aaa; font-style: italic; }
  .progress-container { width: 100%; height: 6px; background: #333; border-radius: 3px; margin: 10px 0; cursor: pointer; }
  .progress-bar { height: 100%; background: #4a8cff; width: 0%; border-radius: 3px; }
  .time-display { display: flex; justify-content: space-between; font-size: 12px; color: #aaa; }
  .status { text-align:center; color:#4a8cff; font-size:14px; margin-top:5px; height:20px; }
  /* cassette animation */
  #cassette { width: 200px; height: 120px; margin: auto; background: #222; border-radius: 10px; position: relative; overflow: hidden; }
  .reel { width: 40px; height: 40px; border-radius: 50%; border: 4px solid #888; position: absolute; top: 40px; }
  .left { left: 30px; }
  .right { right: 30px; }
  .spinning { animation: spin 2s linear infinite; }
  @keyframes spin { 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);} }
</style>
</head>
<body>
<h1>üéß NextDev MP3 Player</h1>
<div id="player">
  <input type="file" id="fileInput" multiple accept=".mp3">
  <ul id="playlist"></ul>
  <div id="cassette">
    <div class="reel left" id="leftReel"></div>
    <div class="reel right" id="rightReel"></div>
  </div>
  <div class="track-info" id="trackInfo">No track selected</div>

  <div class="progress-container" id="progressContainer">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <div class="time-display">
    <span id="currentTime">0:00</span>
    <span id="totalTime">0:00</span>
  </div>

  <div id="controls">
    <button id="prevBtn">‚èÆÔ∏è Prev</button>
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="stopBtn">‚èπÔ∏è Stop</button>
    <button id="nextBtn">‚è≠Ô∏è Next</button>
    <button id="shuffleBtn">üîÄ Shuffle</button>
    <button id="repeatBtn">üîÅ Repeat</button>
    <input type="range" id="volume" min="0" max="1" step="0.01" value="0.7">
  </div>

  <div id="equalizer">
    <div><label>Bass</label><br><input type="range" id="bass" min="-40" max="40" value="0"></div>
    <div><label>Mid</label><br><input type="range" id="mid" min="-40" max="40" value="0"></div>
    <div><label>Treble</label><br><input type="range" id="treble" min="-40" max="40" value="0"></div>
  </div>

  <label>‚è±Ô∏è Crossfade Duration (sec): <input type="number" id="crossfadeDuration" value="5" min="0" max="30"></label>
  <div class="status" id="status"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
const fileInput = document.getElementById('fileInput');
const playlist = document.getElementById('playlist');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const repeatBtn = document.getElementById('repeatBtn');
const volumeSlider = document.getElementById('volume');
const bassSlider = document.getElementById('bass');
const midSlider = document.getElementById('mid');
const trebleSlider = document.getElementById('treble');
const crossfadeInput = document.getElementById('crossfadeDuration');
const trackInfo = document.getElementById('trackInfo');
const progressBar = document.getElementById('progressBar');
const progressContainer = document.getElementById('progressContainer');
const currentTimeDisplay = document.getElementById('currentTime');
const totalTimeDisplay = document.getElementById('totalTime');
const status = document.getElementById('status');
const leftReel = document.getElementById('leftReel');
const rightReel = document.getElementById('rightReel');

let audioCtx, currentSource, gainNode, bass, mid, treble;
let audioBuffers = [];
let currentIndex = -1, isPlaying = false;
let startTime = 0, pausedAt = 0, animationFrame;
let shuffle = false, repeat = false;
let crossfadeTriggered = false;

// --- Playlist setup ---
fileInput.addEventListener('change', e => {
  for (const file of Array.from(e.target.files)) {
    const li = document.createElement('li');
    li.textContent = file.name;
    li.file = file;
    playlist.appendChild(li);
  }
});

new Sortable(playlist, { animation: 150 });

playlist.addEventListener('click', async e => {
  if (e.target.tagName === 'LI') {
    currentIndex = [...playlist.children].indexOf(e.target);
    await playTrack(currentIndex);
  }
});

// --- Audio setup ---
function setupAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  gainNode = audioCtx.createGain();
  bass = audioCtx.createBiquadFilter(); 
  bass.type = 'lowshelf'; 
  bass.frequency.value = 200;
  mid = audioCtx.createBiquadFilter(); 
  mid.type = 'peaking'; 
  mid.frequency.value = 1000;
  treble = audioCtx.createBiquadFilter(); 
  treble.type = 'highshelf'; 
  treble.frequency.value = 3000;
  
  bass.connect(mid); 
  mid.connect(treble); 
  treble.connect(gainNode); 
  gainNode.connect(audioCtx.destination);
  gainNode.gain.value = volumeSlider.value;
}

async function loadBuffer(index) {
  if (audioBuffers[index]) return audioBuffers[index];
  const file = playlist.children[index].file;
  const arrayBuffer = await file.arrayBuffer();
  const buffer = await audioCtx.decodeAudioData(arrayBuffer);
  audioBuffers[index] = buffer;
  return buffer;
}

// --- Play Track ---
async function playTrack(index, seekPosition = 0) {
  stopCurrent();
  if (!audioCtx) setupAudio();
  
  const buffer = await loadBuffer(index);
  currentSource = audioCtx.createBufferSource();
  currentSource.buffer = buffer;
  currentSource.connect(bass);
  currentSource.start(0, seekPosition);
  
  startTime = audioCtx.currentTime - seekPosition;
  isPlaying = true;
  crossfadeTriggered = false;
  
  updateUI();
  
  currentSource.onended = () => { 
    if (isPlaying && !crossfadeTriggered) {
      nextTrack(true);
    }
  };
  
  spinReels(true);
}

function stopCurrent() {
  if (currentSource) { 
    try {
      currentSource.stop(); 
    } catch (e) {
      // Source may already be stopped
    }
    currentSource.disconnect(); 
    currentSource = null; 
  }
  isPlaying = false;
  crossfadeTriggered = false;
  spinReels(false);
}

function updateUI() {
  const li = playlist.children[currentIndex];
  [...playlist.children].forEach(li => li.classList.remove('playing'));
  if (li) li.classList.add('playing');
  trackInfo.textContent = li ? li.file.name : 'No track';
  if (animationFrame) cancelAnimationFrame(animationFrame);
  updateProgress();
}

function updateProgress() {
  if (!currentSource || !currentSource.buffer) return;
  
  const elapsed = audioCtx.currentTime - startTime;
  const duration = currentSource.buffer.duration;
  progressBar.style.width = Math.min((elapsed / duration) * 100, 100) + '%';
  currentTimeDisplay.textContent = formatTime(elapsed);
  totalTimeDisplay.textContent = formatTime(duration);
  
  // Check for crossfade trigger
  const crossfade = parseFloat(crossfadeInput.value || '0');
  if (crossfade > 0 && duration - elapsed <= crossfade && isPlaying && !crossfadeTriggered) {
    crossfadeTriggered = true;
    nextTrack(true);
  }
  
  if (isPlaying) {
    animationFrame = requestAnimationFrame(updateProgress);
  }
}

function formatTime(sec) { 
  const m = Math.floor(sec / 60); 
  const s = Math.floor(sec % 60); 
  return `${m}:${s < 10 ? '0' : ''}${s}`; 
}

async function crossfadeTracks(oldSource, newIndex, crossfadeDuration) {
  try {
    // Load the new track buffer
    const newBuffer = await loadBuffer(newIndex);
    
    // Create new source for the next track
    const newSource = audioCtx.createBufferSource();
    newSource.buffer = newBuffer;
    
    // Create separate gain nodes for crossfading
    const oldGain = audioCtx.createGain();
    const newGain = audioCtx.createGain();
    
    // Reconnect old source through its gain node
    oldSource.disconnect();
    oldSource.connect(oldGain);
    oldGain.connect(bass);
    
    // Connect new source through its gain node
    newSource.connect(newGain);
    newGain.connect(bass);
    
    // Set up crossfade timing
    const now = audioCtx.currentTime;
    
    // Fade out old track
    oldGain.gain.setValueAtTime(1, now);
    oldGain.gain.linearRampToValueAtTime(0, now + crossfadeDuration);
    
    // Fade in new track
    newGain.gain.setValueAtTime(0, now);
    newGain.gain.linearRampToValueAtTime(1, now + crossfadeDuration);
    
    // Start the new track
    newSource.start(0, 0);
    
    // Stop the old track after crossfade completes
    setTimeout(() => {
      try {
        oldSource.stop();
      } catch (e) {
        // Source may already be stopped
      }
    }, crossfadeDuration * 1000);
    
    // Update current source reference
    currentSource = newSource;
    
    // Reset timing for the new track
    startTime = audioCtx.currentTime;
    
    // Set up ended handler for the new track
    newSource.onended = () => { 
      if (isPlaying && !crossfadeTriggered) {
        nextTrack(true);
      }
    };
    
    status.textContent = `Crossfading to next track (${crossfadeDuration}s)`;
    setTimeout(() => {
      status.textContent = '';
    }, 2000);
    
    return true;
  } catch (error) {
    console.error('Crossfade error:', error);
    status.textContent = 'Crossfade failed, switching normally';
    return false;
  }
}

// --- Next/Prev ---
async function nextTrack(auto = false) {
  if (playlist.children.length === 0) return;
  
  let nextIndex;
  if (shuffle) {
    nextIndex = Math.floor(Math.random() * playlist.children.length);
  } else {
    nextIndex = currentIndex + 1;
    if (nextIndex >= playlist.children.length) {
      if (repeat) {
        nextIndex = 0;
      } else {
        stopCurrent();
        return;
      }
    }
  }
  
  const crossfadeDuration = parseFloat(crossfadeInput.value || '0');
  
  if (auto && crossfadeDuration > 0 && currentSource && isPlaying) {
    // Perform crossfade
    const oldSource = currentSource;
    const oldIndex = currentIndex;
    currentIndex = nextIndex;
    
    const success = await crossfadeTracks(oldSource, nextIndex, crossfadeDuration);
    
    if (success) {
      updateUI();
    } else {
      // Fallback to normal track change
      await playTrack(nextIndex);
    }
  } else {
    // Normal track change without crossfade
    currentIndex = nextIndex;
    await playTrack(nextIndex);
  }
}

async function prevTrack() { 
  if (playlist.children.length === 0) return; 
  currentIndex = currentIndex - 1 < 0 ? playlist.children.length - 1 : currentIndex - 1; 
  await playTrack(currentIndex); 
}

// --- Controls ---
playBtn.addEventListener('click', async () => { 
  if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume(); 
  if (!isPlaying) { 
    if (currentIndex < 0) currentIndex = 0; 
    await playTrack(currentIndex, pausedAt); 
    pausedAt = 0;
  } 
});

pauseBtn.addEventListener('click', () => { 
  if (isPlaying) { 
    pausedAt = audioCtx.currentTime - startTime; 
    currentSource.stop(); 
    isPlaying = false; 
    spinReels(false); 
  }
});

stopBtn.addEventListener('click', () => {
  stopCurrent();
  pausedAt = 0;
});

nextBtn.addEventListener('click', () => nextTrack(false));
prevBtn.addEventListener('click', prevTrack);

shuffleBtn.addEventListener('click', () => { 
  shuffle = !shuffle; 
  shuffleBtn.style.background = shuffle ? '#4a8cff' : '#222'; 
});

repeatBtn.addEventListener('click', () => { 
  repeat = !repeat; 
  repeatBtn.style.background = repeat ? '#4a8cff' : '#222'; 
});

volumeSlider.addEventListener('input', () => { 
  if (gainNode) gainNode.gain.setValueAtTime(volumeSlider.value, audioCtx.currentTime); 
});

bassSlider.addEventListener('input', () => { 
  if (bass) bass.gain.value = bassSlider.value; 
});

midSlider.addEventListener('input', () => { 
  if (mid) mid.gain.value = midSlider.value; 
});

trebleSlider.addEventListener('input', () => { 
  if (treble) treble.gain.value = trebleSlider.value; 
});

// --- Reel animation ---
function spinReels(on) { 
  if (on) { 
    leftReel.classList.add('spinning'); 
    rightReel.classList.add('spinning'); 
  } else { 
    leftReel.classList.remove('spinning'); 
    rightReel.classList.remove('spinning'); 
  } 
}

// --- Progress click seek ---
progressContainer.addEventListener('click', e => {
  if (!currentSource || !currentSource.buffer) return;
  const rect = progressContainer.getBoundingClientRect();
  const clickPos = (e.clientX - rect.left) / rect.width;
  const seekTime = clickPos * currentSource.buffer.duration;
  
  pausedAt = seekTime;
  if (isPlaying) {
    playTrack(currentIndex, seekTime);
  }
});
</script>
</body>
</html>
