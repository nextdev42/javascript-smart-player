<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>üéß NextDev MP3 Player</title>
<style>
body {
  font-family: 'Arial', sans-serif;
  background: #111;
  color: #fff;
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
h1 { text-align: center; margin-bottom: 10px; }
#playlist {
  list-style: none;
  padding: 0;
  max-height: 200px;
  overflow-y: auto;
  width: 100%;
  margin-bottom: 10px;
}
#playlist li {
  padding: 8px 12px;
  margin: 5px 0;
  background: #222;
  border-radius: 4px;
  cursor: grab;
  transition: background 0.2s;
}
#playlist li:hover { background: #444; }
#playlist li.playing { background: #2a5a83; font-weight: bold; }

.controls, .equalizer { display: flex; justify-content: center; gap: 10px; margin: 10px 0; flex-wrap: wrap; }
input[type="range"] { width: 100px; }
.slider-group { text-align: center; }

.track-info { margin: 10px 0; font-style: italic; color: #aaa; text-align: center; }
.status { text-align: center; margin-top: 5px; color: #4a8cff; min-height: 20px; }

.progress-container { width: 100%; height: 6px; background: #333; border-radius: 3px; cursor: pointer; margin-bottom: 5px; }
.progress-bar { height: 100%; background: #4a8cff; border-radius: 3px; width: 0%; }
.time-display { display: flex; justify-content: space-between; width: 100%; font-size: 12px; color: #aaa; margin-bottom:10px; }

/* Cassette animation */
.cassette {
  position: relative;
  width: 250px;
  height: 120px;
  background: #222;
  border: 4px solid #444;
  border-radius: 10px;
  margin: 10px 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
}
.reel {
  width: 60px;
  height: 60px;
  border: 3px solid #888;
  border-radius: 50%;
  background: radial-gradient(circle at center, #666 0%, #222 70%);
  position: relative;
  animation: spin 2s linear infinite;
}
.reel::after {
  content:'';
  position:absolute;
  width:8px; height:8px;
  background:#222;
  border-radius:50%;
  top:50%; left:50%;
  transform:translate(-50%,-50%);
}
@keyframes spin {
  0% { transform: rotate(0deg);}
  100% { transform: rotate(360deg);}
}
.cassette-body { flex:1; margin:0 10px; background:#333; border-radius:6px; }

</style>
</head>
<body>

<h1>üéß NextDev MP3 Player</h1>
<input type="file" id="fileInput" multiple accept=".mp3" />

<ul id="playlist"></ul>

<div class="cassette">
  <div class="reel" id="reelLeft"></div>
  <div class="cassette-body"></div>
  <div class="reel" id="reelRight"></div>
</div>

<div class="track-info" id="trackInfo">No track selected</div>

<div class="progress-container" id="progressContainer">
  <div class="progress-bar" id="progressBar"></div>
</div>
<div class="time-display">
  <span id="currentTime">0:00</span>
  <span id="totalTime">0:00</span>
</div>

<div class="controls">
  <button id="prevBtn">‚èÆÔ∏è</button>
  <button id="playBtn">‚ñ∂Ô∏è</button>
  <button id="pauseBtn">‚è∏Ô∏è</button>
  <button id="stopBtn">‚èπÔ∏è</button>
  <button id="nextBtn">‚è≠Ô∏è</button>
  <button id="shuffleBtn">üîÄ</button>
  <button id="repeatBtn">üîÅ</button>
  <input type="range" id="volume" min="0" max="1" step="0.01" value="0.7"/>
  <label>‚è±Ô∏è Crossfade <input type="number" id="crossfadeDuration" value="5" min="0" max="30" /></label>
</div>

<div class="equalizer">
  <div class="slider-group"><label>Bass</label><br><input type="range" id="bass" min="-40" max="40" value="0" /></div>
  <div class="slider-group"><label>Mid</label><br><input type="range" id="mid" min="-40" max="40" value="0" /></div>
  <div class="slider-group"><label>Treble</label><br><input type="range" id="treble" min="-40" max="40" value="0" /></div>
</div>

<div class="status" id="status"></div>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
const fileInput = document.getElementById('fileInput');
const playlist = document.getElementById('playlist');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const repeatBtn = document.getElementById('repeatBtn');
const volumeSlider = document.getElementById('volume');
const bassSlider = document.getElementById('bass');
const midSlider = document.getElementById('mid');
const trebleSlider = document.getElementById('treble');
const crossfadeInput = document.getElementById('crossfadeDuration');
const trackInfo = document.getElementById('trackInfo');
const progressBar = document.getElementById('progressBar');
const progressContainer = document.getElementById('progressContainer');
const currentTimeDisplay = document.getElementById('currentTime');
const totalTimeDisplay = document.getElementById('totalTime');
const status = document.getElementById('status');

let audioCtx, gainNode, source;
let bass, mid, treble;
let audioBuffers = [];
let currentIndex = -1;
let isPlaying = false;
let startTime = 0;
let pausedAt = 0;
let animationFrame;
let isCrossfading = false;
let shuffle = false;
let repeat = false;

// --- Playlist + Drag + Add ---
fileInput.addEventListener('change', e => {
  for (const file of Array.from(e.target.files)) {
    const li = document.createElement('li');
    li.textContent = file.name;
    li.file = file;
    playlist.appendChild(li);
    audioBuffers.push(null);
  }
});

new Sortable(playlist, {
  animation: 150,
  onEnd: function(evt){
    const oldBuffers = [...audioBuffers];
    audioBuffers = [];
    [...playlist.children].forEach(li=>{
      const idx = Array.from(evt.from.children).indexOf(li);
      audioBuffers.push(oldBuffers[idx] || null);
    });
  }
});

// --- Audio setup ---
function setupAudioNodes() {
  if(audioCtx && audioCtx.state !== 'closed') return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  gainNode = audioCtx.createGain();

  bass = audioCtx.createBiquadFilter(); bass.type='lowshelf'; bass.frequency.value=200;
  mid = audioCtx.createBiquadFilter(); mid.type='peaking'; mid.frequency.value=1000;
  treble = audioCtx.createBiquadFilter(); treble.type='highshelf'; treble.frequency.value=3000;

  bass.connect(mid); mid.connect(treble); treble.connect(gainNode); gainNode.connect(audioCtx.destination);
  gainNode.gain.value = volumeSlider.value;
}

async function playTrack(index){
  stopAudio(false);
  if(!audioCtx) setupAudioNodes();
  currentIndex = index;

  const li = playlist.children[currentIndex];
  if(!audioBuffers[currentIndex]){
    const arrayBuffer = await li.file.arrayBuffer();
    audioBuffers[currentIndex] = await audioCtx.decodeAudioData(arrayBuffer);
  }

  source = audioCtx.createBufferSource();
  source.buffer = audioBuffers[currentIndex];
  source.connect(bass);
  startTime = audioCtx.currentTime - pausedAt;
  source.start(0, pausedAt);
  isPlaying = true;

  [...playlist.children].forEach(li=>li.classList.remove('playing'));
  li.classList.add('playing');
  trackInfo.textContent = `Now Playing: ${li.file.name}`;

  if(animationFrame) cancelAnimationFrame(animationFrame);
  updateProgress();

  source.onended = () => {
    if(isPlaying) nextTrack();
  };
}

function stopAudio(resetUI=true){
  if(source){ source.stop(); source.disconnect(); source=null; }
  pausedAt = 0; isPlaying=false; isCrossfading=false;
  if(animationFrame) cancelAnimationFrame(animationFrame);
  if(resetUI){
    progressBar.style.width='0%';
    currentTimeDisplay.textContent='0:00';
    status.textContent='';
  }
}

function nextTrack(){
  let nextIndex;
  if(shuffle){
    nextIndex = Math.floor(Math.random()*playlist.children.length);
  } else {
    nextIndex = currentIndex+1;
    if(nextIndex>=playlist.children.length){
      if(repeat) nextIndex=0;
      else return stopAudio();
    }
  }
  crossfadeToNext(nextIndex);
}

// --- Crossfade ---
async function crossfadeToNext(nextIndex){
  if(!playlist.children[nextIndex]) return;
  const oldSource = source;
  const li = playlist.children[nextIndex];
  if(!audioBuffers[nextIndex]){
    const arrayBuffer = await li.file.arrayBuffer();
    audioBuffers[nextIndex] = await audioCtx.decodeAudioData(arrayBuffer);
  }
  const newSource = audioCtx.createBufferSource();
  newSource.buffer = audioBuffers[nextIndex];
  newSource.connect(bass);

  const fade = parseFloat(crossfadeInput.value||'0');
  if(fade>0){
    isCrossfading=true;
    const oldGain = audioCtx.createGain();
    const newGain = audioCtx.createGain();
    oldSource.disconnect(); oldSource.connect(oldGain); oldGain.connect(bass);
    newSource.disconnect(); newSource.connect(newGain); newGain.connect(bass);

    const now = audioCtx.currentTime;
    oldGain.gain.setValueAtTime(1,now);
    oldGain.gain.linearRampToValueAtTime(0,now+fade);
    newGain.gain.setValueAtTime(0,now);
    newGain.gain.linearRampToValueAtTime(1,now+fade);

    newSource.start();
    oldSource.stop(now+fade);
    source=newSource;
    currentIndex=nextIndex;
    isCrossfading=false;
  } else {
    playTrack(nextIndex);
  }

  [...playlist.children].forEach(li=>li.classList.remove('playing'));
  li.classList.add('playing');
  trackInfo.textContent=`Now Playing: ${li.file.name}`;
  pausedAt=0; startTime=audioCtx.currentTime;
}

// --- Progress & UI ---
function updateProgress(){
  if(!source || !source.buffer) return;
  const curTime = pausedAt + (audioCtx.currentTime-startTime);
  const dur = source.buffer.duration;
  progressBar.style.width=`${(curTime/dur)*100}%`;
  currentTimeDisplay.textContent=formatTime(curTime);
  totalTimeDisplay.textContent=formatTime(dur);

  if(parseFloat(crossfadeInput.value)>0 && dur-curTime<=parseFloat(crossfadeInput.value) && !isCrossfading && playlist.children.length>1){
    nextTrack();
  }

  if(isPlaying) animationFrame=requestAnimationFrame(updateProgress);
}
function formatTime(sec){ const m=Math.floor(sec/60); const s=Math.floor(sec%60); return `${m}:${s<10?'0':''}${s}`; }

// --- Controls ---
playBtn.addEventListener('click',()=>{ if(!isPlaying) playTrack(currentIndex>=0?currentIndex:0); });
pauseBtn.addEventListener('click',()=>{ if(isPlaying){ pausedAt+=audioCtx.currentTime-startTime; source.stop(); isPlaying=false; } });
stopBtn.addEventListener('click',()=>{ stopAudio(); });
prevBtn.addEventListener('click',()=>{ let i=currentIndex-1; if(i<0) i=playlist.children.length-1; crossfadeToNext(i); });
nextBtn.addEventListener('click',()=>{ nextTrack(); });
shuffleBtn.addEventListener('click',()=>{ shuffle=!shuffle; shuffleBtn.style.background=shuffle?'#4a8cff':'none'; });
repeatBtn.addEventListener('click',()=>{ repeat=!repeat; repeatBtn.style.background=repeat?'#4a8cff':'none'; });

volumeSlider.addEventListener('input',()=>{ if(gainNode) gainNode.gain.setValueAtTime(volumeSlider.value,audioCtx.currentTime); });
bassSlider.addEventListener('input',()=>{ if(bass) bass.gain.value=bassSlider.value; });
midSlider.addEventListener('input',()=>{ if(mid) mid.gain.value=midSlider.value; });
trebleSlider.addEventListener('input',()=>{ if(treble) treble.gain.value=trebleSlider.value; });

// --- Seek by progress bar ---
progressContainer.addEventListener('click', e=>{
  if(!source||!source.buffer) return;
  const rect=progressContainer.getBoundingClientRect();
  const pos=(e.clientX-rect.left)/rect.width;
  pausedAt=pos*source.buffer.duration;
  playTrack(currentIndex);
});
</script>

</body>
</html>
